!function(n){var e={};function o(t){if(e[t])return e[t].exports;var r=e[t]={i:t,l:!1,exports:{}};return n[t].call(r.exports,r,r.exports,o),r.l=!0,r.exports}o.m=n,o.c=e,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="",o(o.s=0)}([function(n,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var t=o(1),r=function(){function n(){}return n.run=function(){var n,e=document.querySelector("#main"),o={seqTime:function(n,e,o,t){e.uniform1f(n,1)},seqCode:function(n,e,o,t){e.uniform1i(n,32784)},sProg:function(n,e,o,t){e.uniform1f(n,.05)}};(n=new t.DR(e,"layout(location = 0) in vec2 pos; \n        out vec4 fragColor;                \n        void main() { \n            gl_Position = vec4(pos.xy,0.0,1.0);\n        }","uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D bufferA;\n        out vec4 fragColor;\n        \n        float rand2d(vec2 co) {\n                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n            }\n            \n            float rand(float n) {\n                return fract(sin(n) * 43758.5453123);\n            }\n            \n            float noise(float p) {\n                    float fl = floor(p);\n                      float fc = fract(p);\n                    return mix(rand(fl), rand(fl + 1.0), fc);\n            }\n            \n            float map(float val, float amin, float amax, float bmin, float bmax) {\n                float n = (val - amin) / (amax-amin);\n                float m = bmin + n * (bmax-bmin);\n                return m;\n            }\n            \n            float snoise(float p){\n                return map(noise(p),0.0,1.0,-1.0,1.0);\n            }\n            \n            float threshold(float val,float cut){\n                float v = clamp(abs(val)-cut,0.0,1.0);\n                v = sign(val) * v;\n                float scale = 1.0 / (1.0 - cut);\n                return v * scale;\n            }\n\n            #define CURVE \n            #define SCANS\n            #define FLICKS\n            //#define GRAINS \n            #define YBUG \n            #define DIRTY\n            //#define STRIP\n            //#define COLOR\n            #define BLINK\n            #define VIG\n            \n            float FREQUENCY = 11.0;\n            \n            vec2 uv_curve(vec2 uv) {\n                    uv = (uv - 0.5) * 2.0;\n                    uv *= 1.2;\t\n                    uv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n                    uv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n                uv /= 1.15;\n                    uv  = (uv / 2.0) + 0.5;\n                    return uv;\n            }\n            \n            vec3 color(sampler2D tex, vec2 uv){        \n                vec3 color = texture(bufferA,uv).rgb;\n                #ifdef COLOR\n                float bw = (color.r + color.g + color.b) / 3.0;\n                color = mix(color,vec3(bw,bw,bw),.95);\n                float p = 1.5;\n                color.r = pow(color.r,p);\n                color.g = pow(color.g,p-0.1);\n                color.b = pow(color.b,p);\n                #endif\n                return color;\n            }\n            \n            vec3 ghost(sampler2D tex, vec2 uv){\n                #ifdef FLICKS\n                \n                float n1 = threshold(snoise(time*10.),.85);\n                float n2 = threshold(snoise(2000.0+time*10.),.85);\n                float n3 = threshold(snoise(3000.0+time*10.),.85);\n                \n                vec2 or = vec2(0.,0.);\n                vec2 og = vec2(0,0.);\n                vec2 ob = vec2(0.,0);\n            \n                float os = .05;\n                or += vec2(n1*os,0.);\n                og += vec2(n2*os,0.);\n                ob += vec2(0.,n3*os);\n              \n                float r = color(bufferA,uv + or).r;\n                float g = color(bufferA,uv + og).g;\n                float b = color(bufferA,uv + ob).b;\n                vec3 color = vec3(r,g,b);\n                return color;\n                #else \n                return texture(bufferA,uv).rgb;\n                #endif\n            }\n            \n            vec2 uv_ybug(vec2 uv){\n                float n4 = clamp(noise(200.0+time*2.)*14.,0.,2.);\n                uv.y += n4;\n                uv.y = mod(uv.y,1.);\n                return uv;\n            }\n            \n            vec2 uv_hstrip(vec2 uv){\n                float vnoise = snoise(time*6.);\n                float hnoise = threshold(snoise(time*10.),.5);\n            \n                float line = (sin(uv.y*10.+vnoise)+1.)/2.;\n                line = (clamp(line,.9,1.)-.9)*10.;\n                \n                uv.x += line * 0.03 * hnoise;\n                uv.x = mod(uv.x,1.);\n                return uv;\n            }\n            \n            \n\n                  \n        void main(){                \n\n\n                float t = float(int(time * FREQUENCY));\n    \n                vec2 uv = gl_FragCoord.xy / resolution.xy;\n                                \n                #ifdef CURVE\n                uv = uv_curve(uv);\n                #endif\n            \n                vec2 ouv = uv;\n                \n                #ifdef GRAINS\n                float xn = threshold(snoise(time*10.),.7) * 0.05;\n                float yn = threshold(snoise((500.0+time)*10.),.7) * 0.05;\n                \n                float r = rand2d(uv+(t+100.0)*.01);\n                uv = uv + vec2(xn,yn) * r;\n                #endif\n                \n                 \n                #ifdef YBUG\n                uv = uv_ybug(uv);\n                #endif\n            \n                #ifdef STRIP\n                uv = uv_hstrip(uv);\n                #endif\n                \n               \n                vec2 onePixel = vec2(0.0, 1.0) / resolution.xy * 3.;\n                #ifdef BLUR\n                vec3 colorA = ghost(bufferA,uv + onePixel,or,og,ob);\n                vec3 colorB = ghost(bufferA,uv - onePixel,or,og,ob);\n                vec3 colorC = ghost(bufferA,uv,or,og,ob);\n                vec3 color = (colorA+colorB+colorC)/3.0;\n                #else\n                vec3 color = ghost(bufferA,uv);\n                #endif\n            \n                //color = colorC;\n                \n                float scanA = (sin(uv.y*3.1415*resolution.y/2.7)+1.)/2.;\n                float scanB = (sin(uv.y*3.1415*1.)+1.)/2.;\n                #ifdef SCANS\n                color *= .75 + scanA * .25;\n                //color *= .5 + scanC * .5;\n                //color *= scanB;    \n                #endif\n                \n                #ifdef BLINK\n                float blink = .96 + .04*(sin(time*100.)+1.)/2.;\n                color *= blink;\n                #endif\n                \n                #ifdef VIG\n                float vig = 44.0 * (ouv.x * (1.0-ouv.x) * ouv.y * (1.0-ouv.y));\n                    vig *= mix( 0.7, 1.0, rand(t + 0.5));\n                color *= .6 + .4*vig;\n                #endif\n                 \n                #ifdef DIRTY\n                color *= 1.0 + rand2d(uv+t*.01) * 0.2;\t\n                #endif\n            \n                vec3 backColor = vec3(.4,.4,.4);\n                if (ouv.x < 0.0 || ouv.x > 1.0)\n                            color = backColor;\n                    if (ouv.y < 0.0 || ouv.y > 1.0)\n                            color = backColor;\n            \n                fragColor = vec4(color,1.0);\n             \n        }")).aA({iChannel0:{src:"assets/iChannel0.png"}},function(){n.aB("bufferA","layout(location = 0) in vec2 pos; \n        out vec4 fragColor;\n        void main() { \n            gl_Position = vec4(pos.xy,0.0,1.0);\n        }","uniform float time;\n        uniform vec2 resolution;\n        \n        uniform float sT;\n        uniform int sC; // use for controlling , cb - controllBits(n)\n        uniform int sI;\n        uniform float sP;\n        \n        uniform sampler2D iChannel0;\n        uniform sampler2D iChannel1;\n\n\n        #define zoom   0.800\n        #define tile   0.350\n        #define speed  0.010 \n\n        #define brightness 0.0015\n        #define darkmatter 0.300\n        #define distfading 0.730\n        #define saturation 0.850\n        \n        out vec4 fragColor;\n\n        vec3 hash33(vec3 p3){\n            p3 = fract(p3 * vec3(.1031,.11369,.13787));\n            p3 += dot(p3, p3.yxz+19.19);\n            return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n        }\n        vec2 cart2polar(vec2 cart) {\n            return vec2(atan(cart.y, cart.x), length(cart));\n        }\n        float noise(float t){\n            return texture(iChannel1,vec2(t,.0)*512.).x;\n        }\n        float noise(vec2 t){\n            return texture(iChannel1,t*512.).x;\n        }\n        vec3 cc(vec3 color, float factor,float factor2){\n            return color;\n            float w = color.x+color.y+color.z;\n            return mix(color,vec3(w)*factor,w*factor2);\n        }        \n        float sat(float x) {\n            return clamp(x, 0., 1.);\n        }        \n        // controlBits \n        float cb(int n) {\n            return float((sC >> n) & 1);\n        }\n        // fractals\n        float map(vec3 p) {\n            return length(p) - 1.0;\n        }\n        \n        // optimize, generic one...\n        vec3 normal( in vec3 pos) {\n            const float eps = 0.002; // precision of the normal computation\n            const vec3 v1 = vec3(1.0, -1.0, -1.0);\n            const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n            const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n            const vec3 v4 = vec3(1.0, 1.0, 1.0);\n        \n            return normalize(v1 * map(pos + v1 * eps) +\n                v2 * map(pos + v2 * eps) +\n                v3 * map(pos + v3 * eps) +\n                v4 * map(pos + v4 * eps));\n        }\n        \n        // Ray's 128, needs to controlled..\n        float raymarch( in vec3 ro, in vec3 rd) {\n            const float maxd = 20.0;\n            const float precis = 0.001;\n            float h = precis * 2.0;\n            float t = 0.0;\n            float res = -1.0;\n            for (int i = 0; i < 128; i++) {\n                if (h < precis || t > maxd) break;\n                h = map(ro + rd * t);\n                t += h;\n            }\n            if (t < maxd) res = t;\n            return res;\n        }\n        \n        vec3 doMaterial( in vec3 pos, in vec3 nor) {\n            vec3 col = vec3(0.);         \n            if(sI == 2){ // set the material to yellow in first scene\n                col = vec3(0.2, 0.07, 0.01);\n            }else // make it a blue tone otherwise.\n            {\n                col = vec3(0.163,0.142,0.500);\n            }\n            return col;            \n        }\n        \n        float calcSoftshadow( in vec3 ro, in vec3 rd) {\n            float res = 1.0;\n            float t = 0.0005; // selfintersection avoidance distance\n            float h = 1.0;\n            for (int i = 0; i < 40; i++) // 40 is the max numnber of raymarching steps\n            {\n                h = map(ro + rd * t);\n                res = min(res, 64.0 * h / t); // 64 is the hardness of the shadows\n                t += clamp(h, 0.02, 2.0); // limit the max and min stepping distances\n            }\n            return clamp(res, 0.0, 1.0);\n        }\n        \n        vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n            vec3 lin = vec3(0.0);        \n            // key light\n            //-----------------------------\n            vec3 lig = normalize(vec3(1.0, 0.7, 0.9));\n            float dif = max(dot(nor, lig), 0.0);\n            float sha = 0.0;\n            if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);\n            lin += dif * vec3(4.00, 4.00, 4.00) * sha;        \n            // ambient light\n            //-----------------------------\n            lin += vec3(0.50, 0.50, 0.50);            \n            // surface-light interacion\n            //-----------------------------\n            vec3 col = mal * lin;       \n            // fog    \n            //-----------------------------\n            col *= exp(-0.01 * dis * dis);\n        \n            return col;\n        }\n\n                \n        void doCamera(out vec3 camPos, out vec3 camTar, in float time, in float mouseX) {\n            float an = 0.3 * time + 10.0 * mouseX;\n            camPos = vec3(2.772 * sin(an), 0.424, 2.820 * cos(an));\n            camTar = vec3(0.000, .000, 0.000);\n        }\n        mat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll) {\n            vec3 ww = normalize(ta - ro);\n            vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n            vec3 vv = normalize(cross(uu, ww));\n            return mat3(uu, vv, ww);\n        }\n\n        // scene X\n\n        vec3 lensflare(vec2 uv,vec2 pos)\n        {\n            vec2 main = uv-pos;\n            vec2 uvd = uv*(length(uv));\n            \n            float ang = atan(main.y, main.x);\n            float dist=length(main); dist = pow(dist,.1);\n            float n = noise(vec2((ang-time/9.0)*16.0,dist*32.0));\n            \n            float f0 = 1.0/(length(uv-pos)*16.0+1.0);\n            \n            f0 = f0+f0*(sin((ang+time/18.0 + noise(abs(ang)+n/2.0)*2.0)*12.0)*.1+dist*.1+.8);\n        \n            float f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n            float f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n            float f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n            \n            vec2 uvx = mix(uv,uvd,-0.5);\n            \n            float f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n            float f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n            float f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n            \n            uvx = mix(uv,uvd,-.4);\n            \n            float f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n            float f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n            float f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n            \n            uvx = mix(uv,uvd,-0.5);\n            \n            float f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n            float f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n            float f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n            \n            vec3 c = vec3(.0);\n            \n            c.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n            c+=vec3(f0);\n            \n            return c;\n        }\n\n        // scene Volumetric stars + lens\n\n        vec3 volclouds(vec2 uv){\n\n            uv.y*=resolution.y/resolution.x;\n    \n            vec3 dir=vec3(uv*zoom,1.);\n            \n            float tm=time*speed+.025;\n\n            float a1= 0.;\n            float a2=.8;\n            \n            mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n            mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n            dir.xz*=rot1;\n            dir.xy*=rot2;\n            vec3 from=vec3(1.,.5,0.5);\n            from+=vec3(tm*2.,tm,-2.);\n            from.xz*=rot1;\n            from.xy*=rot2;\n            \n            //volumetric rendering\n            float s=0.1,fade=1.;\n            vec3 v=vec3(0.);\n            \n            for (int r=0; r<20; r++) {\n                vec3 p=from+s*dir*.5;\n                p = abs(vec3(tile)-mod(p,vec3(tile*2.))); //  fold\n                float pa,a=pa=0.;\n                for (int i=0; i<17; i++) {             \n                    p=abs(p)/dot(p,p)-.53; \n                    a+=abs(length(p)-pa); \n                    pa=length(p);\n                }\n                float dm=max(0.,0.300-a*a*.001); \n                a*=a*a; // add contrast        \n                if (r>6) fade*=1.-dm; \t\t\n                v+=vec3(dm,dm*.5,0.);        \n                v+=fade;\n                v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; \n                fade*=distfading; \n                s+=0.1;\n            }\n            \n            v=mix(vec3(length(v)),v,saturation); \n            \n            vec2 lp = vec2(-0.580,0.170);\n            \n            vec3 lens =  vec3(1.053,1.131,1.400)*lensflare(uv / .55+sin(time)*0.01,lp); \n            \n            lens = cc(lens,1.0,.1);\n            \n            return mix(lens,v*0.01,0.2);\n\n        }       \n\n        // scene 2\n        vec3 galaxy(vec2 uv){\n\n            float t = time * .1 + ((.25 + .05 * sin(time * .1))/(length(uv.xy) + .07)) * 2.2;\n            float si = sin(t);\n            float co = cos(t);\n            mat2 ma = mat2(co, si, -si, co);\n        \n            float v1, v2, v3;\n            v1 = v2 = v3 = 0.0;\n            \n            float s = 0.0;\n            for (int i = 0; i < 90; i++){\n                vec3 p = s * vec3(uv, 0.0);\n                p.xy *= ma;\n                p += vec3(.22, .3, s - 1.5 - sin(time * .13) * .1);\n                for (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n                v2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - time * .3));\n                v3 += length(p.xy*10.) * .0003;\n                s  += .035;\n            }\n            \n            float len = length(uv);\n            v1 *= smoothstep(.7, .0, len);\n            v2 *= smoothstep(.5, .0, len);\n            v3 *= smoothstep(.9, .0, len);\n            \n            vec3 col = vec3( v3 * (1.5 + sin(time * .2) * .4),\n                            (v1 + v3) * .3,\n                             v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\t\n                            \n            return min(pow(abs(col), vec3(1.2)), 1.0);\t\t\t\t\n        }\n        \n\n        vec3 doBackground(vec3 p){\n            return vec3(0.);\n        }\n\n        vec3 scenes(vec2 uv){\n           \n            vec3 col = doBackground(vec3(0.));\n\n            return volclouds(uv);\n\n            if(sI ==2){\n                col = galaxy(uv);\n            }else if(sI ==4){\n\n                col = volclouds(uv);\n\n            }            \n            else{\n                vec3 ro, ta;\n                    doCamera(ro, ta, time, 0.);\n                \n                mat3 camMat = calcLookAtMatrix(ro, ta, 0.0); // 0.0 is the camera roll            \n                \n                vec3 rd = normalize(camMat * vec3(uv.xy, 2.0)); // 2.0 is the lens length\n                float t = raymarch(ro, rd);\n\n                if (t > -0.5) {\n                    vec3 pos = ro + t * rd;\n                    vec3 nor = normal(pos);\n            \n                    vec3 mal = doMaterial(pos, nor);\n            \n                    col = doLighting(pos, nor, rd, t, mal);\n                }   \n\n            }\n           \n            return col;\n        }\n\n\n        void main() {\n        \n            vec2 uv = (-resolution.xy + 2. * gl_FragCoord.xy) / resolution.y;\n               \n            vec3 scol = scenes(uv);\n           \n            // Scene fade using progress & controlbits        \n          ///  scol = clamp(scol, 0., 1.) * sat(cb(14) + 15. * sP) * sat(cb(13) + 5. - 5. * sP);\n        \n            fragColor = vec4(scol, 1);\n        \n        }",["iChannel0"]).run(0,o)})},n}();e.Example=r,setTimeout(function(){r.run()},3e3)},function(n,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var t=function(){function n(n,e,o){this.a=n,this.b=e,this.textures=o,this.c=n}return n.prototype.swap=function(){var n=this.a;this.a=this.b,this.b=n},n}();e.CH=t;var r=function(){return function(n,e,o){this.framebuffer=n.createFramebuffer(),this.texture=n.createTexture(),this.renderBuffer=n.createRenderbuffer(),n.bindTexture(3553,this.texture),n.texImage2D(3553,0,6408,e,o,0,6408,5121,null),n.texParameteri(3553,10242,33071),n.texParameteri(3553,10243,33071),n.texParameteri(3553,10240,9728),n.texParameteri(3553,10241,9728),n.bindFramebuffer(36160,this.framebuffer),n.framebufferTexture2D(36160,36064,3553,this.texture,0),n.bindRenderbuffer(36161,this.renderBuffer),n.renderbufferStorage(36161,33189,e,o),n.framebufferRenderbuffer(36160,36096,36161,this.renderBuffer),n.bindTexture(3553,null),n.bindRenderbuffer(36161,null),n.bindFramebuffer(36160,null)}}();e.RT=r;var a=function(){function n(n,e,o){this.canvas=n,this.header="#version 300 es\n        #ifdef GL_ES\n                precision highp float;\n                precision highp int;\n                precision mediump sampler3D;\n        #endif\n        ",this.channels=new Map,this.programs=new Map,this.textureCache=new Map,this.gl=n.getContext("webgl2",{preserveDrawingBuffer:!0});var t,r=this.gl,a=0;for(var i in r)"function"==typeof r[i]&&(r[t=(t=(255&a++).toString(16)).match(/^[0-9].*$/)?"x"+t:t]=r[i]);if(r.viewport(0,0,n.width,n.height),this.buffer=r.createBuffer(),this.surfaceBuffer=r.createBuffer(),this.mainProgram=r.createProgram(),this.cS(this.mainProgram,35633,this.header+e),this.cS(this.mainProgram,35632,this.header+o),r.linkProgram(this.mainProgram),this.gl.validateProgram(this.mainProgram),!r.getProgramParameter(this.mainProgram,r.LINK_STATUS))throw"Could not compile WebGL program. \n\n"+r.getProgramInfoLog(this.mainProgram);r.useProgram(this.mainProgram),this.screenVertexPosition=r.getAttribLocation(this.mainProgram,"pos"),r.enableVertexAttribArray(this.screenVertexPosition),r.bindBuffer(34962,this.buffer),r.bufferData(34962,new Float32Array([-1,-1,1,-1,-1,1,1,-1,1,1,-1,1]),35044)}return n.prototype.cS=function(n,e,o){var t=this.gl,r=t.createShader(e);if(t.shaderSource(r,o),t.compileShader(r),t.attachShader(n,r),!this.gl.getShaderParameter(r,35713))throw this.gl.getShaderInfoLog(r).trim().split("\n").forEach(function(n){return console.error("[shader] "+n)}),new Error("Error while compiling vertex/fragment"+o)},n.prototype.aP=function(n){var e=this.gl.createProgram();return this.programs.set(n,e),e},n.prototype.t=function(n){var e=this.gl,o=e.createTexture();return e.bindTexture(3553,o),e.texImage2D(3553,0,6408,6408,5121,n),e.generateMipmap(3553),o},n.prototype.aA=function(n,e){var o=this,t=Object.keys(n).length;return Object.keys(n).forEach(function(r){var a=new Image;a.onload=function(n){o.textureCache.set(r,o.t(a)),o.textureCache.size===t&&e()},a.src=n[r].src}),this},n.prototype.aB=function(n,e,o,t){var r=this,a=this.gl,i=this.cC(this.canvas.width,this.canvas.height,t||[]);this.channels.set(n,i);var c=this.aP(n);if(this.cS(c,35633,this.header+e),this.cS(c,35632,this.header+o),a.linkProgram(c),a.validateProgram(c),!a.getProgramParameter(c,a.LINK_STATUS))throw"Could not compile WebGL program. \n\n"+a.getProgramInfoLog(c);return a.useProgram(c),t&&t.forEach(function(n){var e=r.textureCache.get(n);a.bindTexture(3553,e)}),this.vertexPosition=a.getAttribLocation(c,"pos"),a.enableVertexAttribArray(this.vertexPosition),this},n.prototype.R=function(n,e){var o=this,t=this.gl,r=this.mainProgram,a=0;this.programs.forEach(function(r,i){t.useProgram(r);var c=o.channels.get(i);t.uniform2f(t.getUniformLocation(r,"resolution"),o.canvas.width,o.canvas.height),t.uniform1f(t.getUniformLocation(r,"time"),n),e&&Object.keys(e).forEach(function(o){e[o](t.getUniformLocation(r,o),t,r,n)}),c.textures.forEach(function(n){var e=t.getUniformLocation(r,n);t.activeTexture(33984+a),t.uniform1i(e,a),a++}),t.bindBuffer(34962,o.surfaceBuffer),t.vertexAttribPointer(0,2,5126,!1,0,0),t.bindBuffer(34962,o.buffer),t.vertexAttribPointer(0,2,5126,!1,0,0),t.bindFramebuffer(36160,c.a.framebuffer),t.clear(16640),t.drawArrays(4,0,6)}),t.useProgram(r),t.uniform2f(t.getUniformLocation(r,"resolution"),this.canvas.width,this.canvas.height),t.uniform1f(t.getUniformLocation(r,"time"),n),t.bindBuffer(34962,this.buffer),t.vertexAttribPointer(0,2,5126,!1,0,0),this.channels.forEach(function(n,e){t.uniform1i(t.getUniformLocation(r,e),a),t.activeTexture(33984+a),t.bindTexture(3553,n.a.texture),a++,n.swap()}),t.bindFramebuffer(36160,null),t.clear(16640),t.drawArrays(4,0,6)},n.prototype.cC=function(n,e,o){var a=this.gl;return new t(new r(a,n,e),new r(a,n,e),o)},n.prototype.run=function(n,e){var o=this,t=performance.now(),r=0,a=function(n){requestAnimationFrame(a),(r=n-t)>1e3/60&&(t=n-r%(1e3/60),o.R(t/1e3,e))};return a(0|n),this},n}();e.DR=a}]);